/**
 * This is a generated file: do not modify.
 *
 * Generated by midl v2.1.0 from 'ParkAssist/vm-specification/repository/apa-repository.ts'.
 *
 * Copyright (c) 2019 Renault SW Labs
 *
 * Developed by Renault SW Labs, an affiliate of RENAULT S.A.S. which holds all
 * intellectual property rights. Use of this software is subject to a specific
 * license granted by RENAULT S.A.S.
 */
package com.renault.parkassist.repository.apa.mock;


import android.app.Application;
import androidx.annotation.FloatRange;
import androidx.annotation.IntRange;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.Size;
import androidx.lifecycle.MutableLiveData;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.renault.parkassist.repository.apa.ApaRepositoryBase;

import com.renault.parkassist.repository.apa.DisplayState;
import com.renault.parkassist.repository.apa.FeatureConfig;
import com.renault.parkassist.repository.apa.Instruction;
import com.renault.parkassist.repository.apa.ManeuverMove;
import com.renault.parkassist.repository.apa.ManeuverSelection;
import com.renault.parkassist.repository.apa.ManeuverStartSwitch;
import com.renault.parkassist.repository.apa.ManeuverType;
import com.renault.parkassist.repository.apa.ScanningSide;
import com.renault.parkassist.repository.apa.ViewMask;

public class ApaRepositoryMock extends ApaRepositoryBase {
	public ApaRepositoryMock(@NonNull Application application) {
		super(application);
		this.reset();
	}

	public void reset() {
		featureConfiguration = FeatureConfig.NONE;
		supportedManeuvers = new ArrayList<Integer>();
		displayState.setValue(DisplayState.DISPLAY_NONE);
		leftSuitable.setValue(false);
		rightSuitable.setValue(false);
		leftSelected.setValue(false);
		rightSelected.setValue(false);
		scanningSide.setValue(ScanningSide.SCANNING_SIDE_NONE);
		automaticManeuver.setValue(false);
		maneuverMove.setValue(ManeuverMove.FIRST);
		maneuverCompletion.setValue(0);
		extendedInstruction.setValue(Instruction.SELECT_SIDE);
		warningMessage.setValue(0);
		defaultManeuverType.setValue(1);
		maneuverSelection.setValue(ManeuverSelection.SELECTED);
		parallelManeuverSelection.setValue(ManeuverSelection.SELECTED);
		perpendicularManeuverSelection.setValue(ManeuverSelection.SELECTED);
		parkOutManeuverSelection.setValue(ManeuverSelection.SELECTED);
		maneuverSwitchSelection.setValue(ManeuverStartSwitch.NONE);
		viewMask.setValue(ViewMask.UNAVAILABLE);
	}

	public void postReset() {
		featureConfiguration = FeatureConfig.NONE;
		supportedManeuvers = new ArrayList<Integer>();
		displayState.postValue(DisplayState.DISPLAY_NONE);
		leftSuitable.postValue(false);
		rightSuitable.postValue(false);
		leftSelected.postValue(false);
		rightSelected.postValue(false);
		scanningSide.postValue(ScanningSide.SCANNING_SIDE_NONE);
		automaticManeuver.postValue(false);
		maneuverMove.postValue(ManeuverMove.FIRST);
		maneuverCompletion.postValue(0);
		extendedInstruction.postValue(Instruction.SELECT_SIDE);
		warningMessage.postValue(0);
		defaultManeuverType.postValue(1);
		maneuverSelection.postValue(ManeuverSelection.SELECTED);
		parallelManeuverSelection.postValue(ManeuverSelection.SELECTED);
		perpendicularManeuverSelection.postValue(ManeuverSelection.SELECTED);
		parkOutManeuverSelection.postValue(ManeuverSelection.SELECTED);
		maneuverSwitchSelection.postValue(ManeuverStartSwitch.NONE);
		viewMask.postValue(ViewMask.UNAVAILABLE);
	}

	@Override
	public int getFeatureConfiguration() {
		return featureConfiguration;
	}

	@NonNull
	@Override
	public List<Integer> getSupportedManeuvers() {
		return supportedManeuvers;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getDisplayState() {
		return displayState;
	}

	@NonNull
	@Override
	public MutableLiveData<Boolean> getLeftSuitable() {
		return leftSuitable;
	}

	@NonNull
	@Override
	public MutableLiveData<Boolean> getRightSuitable() {
		return rightSuitable;
	}

	@NonNull
	@Override
	public MutableLiveData<Boolean> getLeftSelected() {
		return leftSelected;
	}

	@NonNull
	@Override
	public MutableLiveData<Boolean> getRightSelected() {
		return rightSelected;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getScanningSide() {
		return scanningSide;
	}

	@NonNull
	@Override
	public MutableLiveData<Boolean> getAutomaticManeuver() {
		return automaticManeuver;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getManeuverMove() {
		return maneuverMove;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getManeuverCompletion() {
		return maneuverCompletion;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getExtendedInstruction() {
		return extendedInstruction;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getWarningMessage() {
		return warningMessage;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getDefaultManeuverType() {
		return defaultManeuverType;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getManeuverSelection() {
		return maneuverSelection;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getParallelManeuverSelection() {
		return parallelManeuverSelection;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getPerpendicularManeuverSelection() {
		return perpendicularManeuverSelection;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getParkOutManeuverSelection() {
		return parkOutManeuverSelection;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getManeuverSwitchSelection() {
		return maneuverSwitchSelection;
	}

	@NonNull
	@Override
	public MutableLiveData<Integer> getViewMask() {
		return viewMask;
	}

	public int featureConfiguration;
	public List<Integer> supportedManeuvers;
	protected MutableLiveData<Integer> displayState = new MutableLiveData<>();
	protected MutableLiveData<Boolean> leftSuitable = new MutableLiveData<>();
	protected MutableLiveData<Boolean> rightSuitable = new MutableLiveData<>();
	protected MutableLiveData<Boolean> leftSelected = new MutableLiveData<>();
	protected MutableLiveData<Boolean> rightSelected = new MutableLiveData<>();
	protected MutableLiveData<Integer> scanningSide = new MutableLiveData<>();
	protected MutableLiveData<Boolean> automaticManeuver = new MutableLiveData<>();
	protected MutableLiveData<Integer> maneuverMove = new MutableLiveData<>();
	protected MutableLiveData<Integer> maneuverCompletion = new MutableLiveData<>();
	protected MutableLiveData<Integer> extendedInstruction = new MutableLiveData<>();
	protected MutableLiveData<Integer> warningMessage = new MutableLiveData<>();
	protected MutableLiveData<Integer> defaultManeuverType = new MutableLiveData<>();
	protected MutableLiveData<Integer> maneuverSelection = new MutableLiveData<>();
	protected MutableLiveData<Integer> parallelManeuverSelection = new MutableLiveData<>();
	protected MutableLiveData<Integer> perpendicularManeuverSelection = new MutableLiveData<>();
	protected MutableLiveData<Integer> parkOutManeuverSelection = new MutableLiveData<>();
	protected MutableLiveData<Integer> maneuverSwitchSelection = new MutableLiveData<>();
	protected MutableLiveData<Integer> viewMask = new MutableLiveData<>();

	

	@Override
	public void requestManeuverType(@ManeuverType int maneuverType) {}

	@Override
	public void acknowledgeWarning(int userAck) {}

	@Override
	public void setDefaultManeuverType(@ManeuverType int maneuverType) {}

	@Override
	public void switchManeuverStartActivation() {}
}
